{"version":3,"sources":["app.js","slider.js","textualizer.js","transform-text.js","init.js"],"names":[],"mappings":"AAAA;AACA;AACA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACliBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA","file":"app.js","sourcesContent":["// The namespace for this application\nvar app = {};\n","  app.slider = function () {\n        var heroTxt = $('#rau-holder');\n\t\t\t\tvar aboutContent=$('.about-content');\n\t\t\t\tvar aboutButton = $('.about-button');\n\t\t    var workButton =$('.work-button');\n\t\t    var contactButton =$('.contact-button');\n\t\t\t\tvar contactContent=$('.contact-content');\n\t\t    var orange = '#E74E30';\n\t\t    var black = '#444444';\n\t\t\t\t\n\t\t\t\t$('.home').css({ 'color': black });\n\t\t\t\n\n\t\t\t\taboutContent.hide();\n\t\t\t\t$('.work').hide();\n\t\t\t\tcontactContent.hide();\n\t\t    console.log('hi');\n\n\t\t\n\t\t\t$('.home').click(function(){\n\t\t\t\t$(this).css({ 'color': black });\n\t\t\t\tworkButton.css({ 'color': orange});\n\t\t\t\taboutButton.css({ 'color': orange});\n\t\t\t\taboutContent.hide();\n\t\t\t\tcontactContent.hide();\n\t\t\t\t$('.work').hide();\n\t\t\t\theroTxt.show();\t\n\t\t\t});\n\t\t\n\t\t\n\t\t   workButton.click(function(){\n\t\t\t\t$(this).css({ 'color': 'black'});\n\t\t\t\t$('.home').css({ 'color': orange});\n\t\t\t\t \t$(this).css({ 'color': black });\n\t\t\t\taboutButton.css({ 'color': orange});\n\t\t\t\tcontactContent.hide();\n\t\t\t\theroTxt.hide();\n\t\t\t\taboutContent.hide();\n\t\t\t\t$('.work').show();\t\t\t\t\t\n\t\t\t});\n\t\t\n\t\t aboutButton.click(function () {\n\t\t\t $(this).css({ 'color': black });\n\t\t\t workButton.css({ 'color': orange});\n\t\t\t $('.home').css({ 'color': orange});\n\t\t\t heroTxt.hide();\n\t\t\t contactContent.hide();\n\t\t\t $('.work').hide();\n\t\t\t aboutContent.fadeIn(3000);\n    });\n\t\t\n\t\t contactButton.click(function () {\n\t\t\t $(this).css({ 'color': black });\n\t\t\t workButton.css({ 'color': orange});\n\t\t\t $('.home').css({ 'color': orange});\n\t\t\t heroTxt.hide();\n\t\t\t contactContent.hide();\n\t\t\t aboutContent.hide();\n\t\t\t $('.work').hide();\n\t\t\t contactContent.fadeIn(3000);\n    });\n\t\t   \n\t};","/**\nTextualizer v2.5.0\n@author Kirollos Risk\n\nDual licensed under the MIT or GPL Version 2 licenses.\n\nCopyright (c) 2011 Kirollos Risk\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n(function ($, window) {\n\n    \"use strict\";\n\n    var Textualizer,\n\n        COMMON_CHARACTER_ARRANGE_DELAY = 1000,\n        REMAINING_CHARACTERS_DELAY = 500,\n        EFFECT_DURATION = 2000,\n        REMAINING_CHARACTERS_APPEARANCE_MAX_DELAY = 2000,\n        REMOVE_CHARACTERS_MAX_DELAY = 2000,\n\n        EVENT_CHANGED = 'textualizer.changed';\n\n    // Gets the computed style of an element\n    function getStyle(element) {\n\n        var computedStyle, key, camelCasedStyle, i, len, styleList = {};\n\n        if (window.getComputedStyle) {\n            computedStyle = window.getComputedStyle(element, null);\n\n            if (computedStyle.length) {\n                for (i = 0, len = computedStyle.length; i < len; i++) {\n                    camelCasedStyle = computedStyle[i].replace(/\\-([a-z])/, function (a, b) {\n                        return b.toUpperCase();\n                    });\n\n                    styleList[camelCasedStyle] = computedStyle.getPropertyValue(computedStyle[i]);\n                }\n            } else {\n                for (key in computedStyle) {\n                    if (typeof computedStyle[key] !== 'function' && key !== 'length') {\n                        styleList[key] = computedStyle[key];\n                    }\n                }\n            }\n        } else {\n            computedStyle = element.currentStyle || element.style;\n\n            for (key in computedStyle) {\n                if (Object.prototype.hasOwnProperty.call(computedStyle, key)) {\n                    styleList[key] = computedStyle[key];\n                }\n            }\n        }\n\n        return styleList;\n    }\n\n    function Character() {\n        this.character = null; // A character\n        this.domNode = null; // The span element that wraps around the character\n        this.pos = null; // The domNode position\n        this.used = false;\n        this.inserted = false;\n        this.visited = false;\n    }\n\n    function Snippet() {\n        this.str = ''; // The text string\n        this.characterList = []; // Array of ch objects\n    }\n\n    Snippet.prototype = {\n        // Loops through <characterList>, and find the first character that matches <val>, and hasn't been already used.\n        use: function (val) {\n            var ch = null;\n\n            $.each(this.characterList, function () {\n                if (this.character === val && !this.used) {\n                    this.used = true;\n                    ch = this;\n                    return false; // break;\n                }\n            });\n\n            return ch;\n        },\n        // Resets ever character in <characterList>\n        reset: function () {\n            $.each(this.characterList, function () {\n                this.inserted = false;\n                this.used = false;\n            });\n        }\n    };\n\n    Textualizer = function ($element, data, options) {\n        var self = this,\n            list = [],\n            snippets,\n\n            index, previous, showCharEffect = null,\n\n            playing = false,\n            paused = false,\n\n            elementHeight, position,\n\n            $clone, $container, $phantomContainer;\n\n        // If an effect is chosen, then look for it in the list of effects\n        if (options.effect !== 'random') {\n            $.each($.fn.textualizer.effects, function () {\n                if (this[0] === options.effect) {\n                    showCharEffect = this[1];\n                    return false; // break;\n                }\n            });\n        }\n\n        // Clone the target element, and remove the id attribute (if it has one)\n        // Why remove the id? Cuz when we clone an element, the id is also copied.  That's a very bad thing,\n        $clone = $element.clone().removeAttr('id').appendTo(window.document.body);\n\n        // Copy all the styles.  This is especially necessary if the clone was being styled by id in a stylesheet)\n        $clone.css(getStyle($element[0]));\n\n        // Note that the clone needs to be visible so we can do the proper calculation\n        // of the position of every character.  Ergo, move the clone outside of the window's\n        // visible area.\n        $clone.css({\n            position: 'absolute',\n            top: '-1000px'\n        });\n\n        $phantomContainer = $('<div />').css({\n            'position': 'relative',\n            'visibility': 'hidden'\n        }).appendTo($clone);\n\n        // Make sure any animating character disappear when outside the boundaries of\n        // the element\n        $element.css('overflow', 'hidden');\n\n        // Contains transitioning text\n        $container = $('<div />').css('position', 'relative').appendTo($element);\n\n        elementHeight = $element.height();\n\n        position = {\n            bottom: elementHeight\n        };\n\n        function positionSnippet(snippet, phantomSnippets) {\n            // If options.centered is true, then we need to center the text.\n            // This cannot be done solely with CSS, because of the absolutely positioned characters\n            // within a relative container.  Ergo, to achieve a vertically-aligned look, do\n            // the following simple math:\n            var yOffset = options.centered ? (elementHeight - $phantomContainer.height()) / 2 : 0;\n\n            // Figure out the positioning, and clone the character's domNode\n            $.each(phantomSnippets, function (index, c) {\n                c.pos = c.domNode.position();\n                c.domNode = c.domNode.clone();\n\n                c.pos.top += yOffset;\n\n                c.domNode.css({\n                    'left': c.pos.left,\n                    'top': c.pos.top,\n                    'position': 'absolute'\n                });\n\n                snippet.characterList.push(c);\n            });\n\n            $phantomContainer.html('');\n        }\n\n        /* PRIVATE FUNCTIONS */\n\n        // Add all chars first to the phantom container. Let the browser deal with the formatting.\n        function addCharsToSnippet(i) {\n            var phantomSnippets = [],\n                snippet = new Snippet(),\n                j, ch, c, len;\n\n            snippet.str = list[i];\n            snippets.push(snippet);\n\n            for (j = 0, len = snippet.str.length; j < len; j++) {\n                ch = snippet.str.charAt(j);\n\n                if (ch === '') {\n                    $phantomContainer.append(' ');\n                } else {\n                    c = new Character();\n                    c.character = ch;\n                    c.domNode = $('<span/>').text(ch);\n\n                    $phantomContainer.append(c.domNode);\n                    phantomSnippets.push(c);\n                }\n            }\n\n            positionSnippet(snippet, phantomSnippets);\n\n            return snippet;\n        }\n\n        function getHideEffect() {\n            var dfd, eff;\n\n            eff = [\n\n            function (target) {\n                dfd = $.Deferred();\n                target.animate({\n                    top: position.bottom,\n                    opacity: 'hide'\n                }, dfd.resolve);\n                return dfd.promise();\n            }, function (target) {\n                dfd = $.Deferred();\n                target.fadeOut(1000, dfd.resolve);\n                return dfd.promise();\n            }];\n\n            return eff[Math.floor(Math.random() * eff.length)];\n        }\n\n        function removeCharacters(previousSnippet, currentSnippet) {\n            var keepList = [],\n                removeList = [],\n                finalDfd = $.Deferred(),\n                hideEffect = getHideEffect(),\n                currChar;\n\n            // For every character in the previous text, check if it exists in the current text.\n            // YES ==> keep the character in the DOM\n            // NO ==> remove the character from the DOM\n            $.each(previousSnippet.characterList, function (index, prevChar) {\n                currChar = currentSnippet.use(prevChar.character);\n\n                if (currChar) {\n                    currChar.domNode = prevChar.domNode; // use the previous DOM domNode\n                    currChar.inserted = true;\n\n                    keepList.push(currChar);\n                } else {\n                    (function hideCharacter(deferred) {\n                        removeList.push(deferred);\n                        hideEffect(prevChar.domNode.delay(Math.random() * REMOVE_CHARACTERS_MAX_DELAY)).done(function () {\n                            prevChar.domNode.remove();\n                            deferred.resolve();\n                        });\n                    })($.Deferred());\n                }\n            });\n\n            $.when.apply(null, removeList).done(function () {\n                return finalDfd.resolve(keepList);\n            });\n\n            return finalDfd.promise();\n        }\n\n        function showCharacters(snippet) {\n            var effects = $.fn.textualizer.effects,\n\n                effect = options.effect === 'random' ? effects[Math.floor(Math.random() * (effects.length - 2)) + 1][1] : showCharEffect,\n\n                finalDfd = $.Deferred(),\n                animationDfdList = [];\n\n            // Iterate through all ch objects\n            $.each(snippet.characterList, function (index, ch) {\n                // If the character has not been already inserted, animate it, with a delay\n                if (!ch.inserted) {\n\n                    ch.domNode.css({\n                        'left': ch.pos.left,\n                        'top': ch.pos.top\n                    });\n\n                    (function animateCharacter(deferred) {\n                        window.setTimeout(function () {\n                            effect({\n                                item: ch,\n                                container: $container,\n                                dfd: deferred\n                            });\n                        }, Math.random() * REMAINING_CHARACTERS_APPEARANCE_MAX_DELAY);\n                        animationDfdList.push(deferred);\n                    })($.Deferred());\n\n                }\n            });\n\n            // When all characters have finished moving to their position, resolve the final promise\n            $.when.apply(null, animationDfdList).done(function () {\n                finalDfd.resolve();\n            });\n\n            return finalDfd.promise();\n        }\n\n        function moveAndShowRemainingCharacters(characters, currentSnippet) {\n            var finalDfd = $.Deferred(),\n                rearrangeDfdList = [];\n\n            // Move charactes that are common to their new position\n            window.setTimeout(function () {\n                $.each(characters, function (index, item) {\n\n                    (function rearrangeCharacters(deferred) {\n                        item.domNode.animate({\n                            'left': item.pos.left,\n                            'top': item.pos.top\n                        }, options.rearrangeDuration, deferred.resolve);\n                        rearrangeDfdList.push(deferred.promise());\n                    })($.Deferred());\n\n                });\n                // When all the characters have moved to their new position, show the remaining characters\n                $.when.apply(null, rearrangeDfdList).done(function () {\n                    window.setTimeout(function () {\n                        showCharacters(currentSnippet).done(function () {\n                            finalDfd.resolve();\n                        });\n                    }, REMAINING_CHARACTERS_DELAY);\n                });\n            }, COMMON_CHARACTER_ARRANGE_DELAY);\n\n            return finalDfd.promise();\n        }\n\n        function rotater() {\n            // If we've reached the last snippet\n            if (index === list.length - 1) {\n\n                // Reset the position of every character in every snippet\n                $.each(snippets, function (j, snippet) {\n                    snippet.reset();\n                });\n                index = -1;\n\n                // If loop=false, pause (i.e., pause at this last blurb)\n                if (!options.loop) {\n                    self.pause();\n                }\n            }\n\n            index++;\n            next(index); // rotate the next snippet\n        }\n\n        function rotate(i) {\n            var dfd = $.Deferred(),\n                current = snippets[i];\n\n            // If this is the first time the blurb is encountered, each character in the blurb is wrapped in\n            // a span and appended to an invisible container, thus we're able to calculate the character's position\n            if (!current) {\n                current = addCharsToSnippet(i);\n            }\n\n            if (previous) {\n                removeCharacters(previous, current).done(function (characters) {\n                    moveAndShowRemainingCharacters(characters, current).done(function () {\n                        dfd.resolve();\n                    });\n                });\n\n            } else {\n                showCharacters(current).done(function () {\n                    dfd.resolve();\n                });\n            }\n\n            previous = current;\n\n            return dfd.promise();\n        }\n\n        function next(i) {\n            if (paused) {\n                return;\n            }\n\n            // <rotate> returns a promise, which completes when a blurb has finished animating.  When that\n            // promise is fulfilled, transition to the next blurb.\n            rotate(i).done(function () {\n                $element.trigger(EVENT_CHANGED, {\n                    index: i\n                });\n                window.setTimeout(rotater, options.duration);\n            });\n        }\n\n        /* PRIVILEDGED FUNCTIONS */\n\n        this.data = function (dataSource) {\n            this.stop();\n            list = dataSource;\n            snippets = [];\n        };\n\n        this.stop = function () {\n            this.pause();\n            playing = false;\n            previous = null;\n            index = 0;\n            $container.empty();\n            $phantomContainer.empty();\n        };\n\n        this.pause = function () {\n            paused = true;\n            playing = false;\n        };\n\n        this.start = function () {\n            if (list.length === 0 || playing) {\n                return;\n            }\n\n            index = index || 0;\n            playing = true;\n            paused = false;\n\n            next(index);\n        };\n\n        this.destroy = function () {\n            $container.parent().removeData('textualizer').end().remove();\n\n            $phantomContainer.remove();\n        };\n\n        if (data && data instanceof Array) {\n            this.data(data);\n        }\n    };\n\n    $.fn.textualizer = function ( /*args*/ ) {\n        var args = arguments,\n            snippets, options, instance, txtlzr;\n\n        // Creates a textualizer instance (if it doesn't already exist)\n        txtlzr = (function ($element) {\n\n            instance = $element.data('textualizer');\n\n            if (!instance) {\n                snippets = [];\n\n                if (args.length === 1 && args[0] instanceof Array) {\n                    snippets = args[0];\n                } else if (args.length === 1 && typeof args[0] === 'object') {\n                    options = args[0];\n                } else if (args.length === 2) {\n                    snippets = args[0];\n                    options = args[1];\n                }\n\n                if (snippets.length === 0) {\n                    $element.find('p').each(function () {\n                        snippets.push($(this).text());\n                    });\n                }\n\n                // Clear the contents in the container, since this is where the blurbs will go\n                $element.html(\"\");\n\n                // Create a textualizer instance, and store in the HTML node's metadata\n                instance = new Textualizer($element, snippets, $.extend({}, $.fn.textualizer.defaults, options));\n                $element.data('textualizer', instance);\n            }\n\n            return instance;\n\n        })(this);\n\n        if (typeof args[0] === 'string' && txtlzr[args[0]]) {\n            txtlzr[args[0]].apply(txtlzr, Array.prototype.slice.call(args, 1));\n        }\n\n        return this;\n    };\n\n    $.fn.textualizer.defaults = {\n        effect: 'random',\n        duration: 2000,\n        rearrangeDuration: 1000,\n        centered: false,\n        loop: true\n    };\n\n    // Effects for characters transition+animation. Customize as you please\n    $.fn.textualizer.effects = [\n        ['none', function (obj) {\n            obj.container.append(obj.item.domNode.show());\n        }],\n        ['fadeIn', function (obj) {\n            obj.container.append(obj.item.domNode.fadeIn(EFFECT_DURATION, obj.dfd.resolve));\n            return obj.dfd.promise();\n        }],\n        ['slideLeft', function (obj) {\n            obj.item.domNode.appendTo(obj.container).css({\n                'left': -1000\n            }).show().animate({\n                'left': obj.item.pos.left\n            }, EFFECT_DURATION, obj.dfd.resolve);\n\n            return obj.dfd.promise();\n        }],\n        ['slideTop', function (obj) {\n            obj.item.domNode.appendTo(obj.container).css({\n                'top': -1000\n            }).show().animate({\n                'top': obj.item.pos.top\n            }, EFFECT_DURATION, obj.dfd.resolve);\n\n            return obj.dfd.promise();\n        }]\n    ];\n\n})(jQuery, window);","app.transformText = function () {\nvar list = ['I can make it better', 'Front-End Development', 'User Research', 'Usability Testing', 'UI/UX Design', 'Creativity', 'And Just Overall Ass-kicking.', 'I can make it better'];  // list of blurbs\nvar txt = $(\"#rau-holder\");\n\t\n\nvar options = {\n  duration: 1000,          // Time (ms) each blurb will remain on screen\n  rearrangeDuration: 300, // Time (ms) a character takes to reach its position\n  effect: 'random',        // Animation effect the characters use to appear\n  centered: true           // Centers the text relative to its container\n};\n\n\n\ntxt.textualizer(list, options); // textualize it!\ntxt.textualizer('start');\n\n\n//txt.textualizer('pause');\t// start\n\t\n};","\napp.transformText();\napp.slider();\n"],"sourceRoot":"/source/"}